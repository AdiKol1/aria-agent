"""
Aria Ambient Intelligence - Actor Base Class

Abstract base class for all actors. Actors prepare actions based on insights
generated by the cortex. They don't execute automatically - they prepare
drafts and suggestions for user approval.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional
import logging

from ..models import Insight, PreparedAction, QuickAction, generate_id, now_iso
from ..constants import ActionType, DeliveryChannel, InsightPriority

logger = logging.getLogger(__name__)


@dataclass
class ActorConfig:
    """Configuration for an actor."""
    enabled: bool = True
    max_options: int = 3  # Maximum alternative versions to generate
    default_channel: DeliveryChannel = DeliveryChannel.VOICE_BRIEFING
    custom_settings: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "enabled": self.enabled,
            "max_options": self.max_options,
            "default_channel": self.default_channel.value,
            "custom_settings": self.custom_settings,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ActorConfig":
        return cls(
            enabled=data.get("enabled", True),
            max_options=data.get("max_options", 3),
            default_channel=DeliveryChannel(data.get("default_channel", "voice")),
            custom_settings=data.get("custom_settings", {}),
        )


class Actor(ABC):
    """
    Abstract base class for action preparers.

    Actors transform insights into prepared actions that the user
    can review and execute. They handle specific types of actions:
    - ContentDrafter: Drafts social posts, articles, responses
    - AlertComposer: Composes notifications and alerts
    - ResearchBriefBuilder: Creates research summaries
    - ScheduleSuggester: Suggests calendar items

    Subclasses must implement:
    - prepare(): Create a PreparedAction from an Insight
    - can_handle(): Check if this actor handles a given insight

    Lifecycle:
    1. can_handle() is called to check if this actor should process an insight
    2. prepare() is called to generate the PreparedAction
    3. The action is queued for delivery
    """

    # Override in subclasses
    name: str = "base"
    description: str = "Base actor class"
    handled_action_types: List[ActionType] = []

    def __init__(self, config: ActorConfig = None, llm_client: Any = None):
        """
        Initialize the actor.

        Args:
            config: Optional configuration
            llm_client: Optional LLM client for content generation
        """
        self._config = config or ActorConfig()
        self._llm = llm_client
        self._prepared_count = 0

    # =========================================================================
    # ABSTRACT METHODS
    # =========================================================================

    @abstractmethod
    async def prepare(self, insight: Insight) -> PreparedAction:
        """
        Prepare an action for an insight.

        This method should:
        1. Analyze the insight content
        2. Generate appropriate action content
        3. Create quick actions if applicable
        4. Return a PreparedAction ready for delivery

        Args:
            insight: The insight to prepare an action for

        Returns:
            PreparedAction with content and options
        """
        pass

    def can_handle(self, insight: Insight) -> bool:
        """
        Check if this actor can handle the given insight.

        Default implementation checks if the insight's action_type
        is in handled_action_types. Override for custom logic.

        Args:
            insight: The insight to check

        Returns:
            True if this actor should handle the insight
        """
        if not self._config.enabled:
            return False

        return insight.action_type in self.handled_action_types

    # =========================================================================
    # CONFIGURATION
    # =========================================================================

    def configure(self, settings: Dict[str, Any]) -> None:
        """Apply configuration settings."""
        if "enabled" in settings:
            self._config.enabled = settings["enabled"]
        if "max_options" in settings:
            self._config.max_options = settings["max_options"]
        if "default_channel" in settings:
            self._config.default_channel = DeliveryChannel(settings["default_channel"])

        # Store custom settings
        custom = {k: v for k, v in settings.items()
                  if k not in {"enabled", "max_options", "default_channel"}}
        self._config.custom_settings.update(custom)

    def get_config(self) -> ActorConfig:
        """Get current configuration."""
        return self._config

    def get_setting(self, key: str, default: Any = None) -> Any:
        """Get a custom setting value."""
        return self._config.custom_settings.get(key, default)

    # =========================================================================
    # HELPERS
    # =========================================================================

    def create_prepared_action(
        self,
        insight: Insight,
        content: str,
        action_type: ActionType = None,
        options: List[str] = None,
        quick_actions: List[QuickAction] = None,
        preferred_channel: DeliveryChannel = None,
    ) -> PreparedAction:
        """
        Create a PreparedAction with common fields populated.

        Args:
            insight: Source insight
            content: Main action content
            action_type: Type of action (defaults to insight's action_type)
            options: Alternative content versions
            quick_actions: One-click actions
            preferred_channel: Delivery channel preference

        Returns:
            PreparedAction object
        """
        self._prepared_count += 1

        return PreparedAction(
            id=generate_id("prep"),
            insight_id=insight.id,
            type=action_type or insight.action_type,
            content=content,
            options=options or [],
            quick_actions=quick_actions or [],
            preferred_channel=preferred_channel or self._get_channel_for_insight(insight),
            status="prepared",
            created_at=now_iso(),
        )

    def _get_channel_for_insight(self, insight: Insight) -> DeliveryChannel:
        """Determine the best delivery channel for an insight."""
        # Critical/high priority: immediate channels
        if insight.priority in [InsightPriority.CRITICAL, InsightPriority.HIGH]:
            return DeliveryChannel.PUSH_NOTIFICATION

        # Check urgency
        if insight.urgency.value == "immediate":
            return DeliveryChannel.PUSH_NOTIFICATION
        elif insight.urgency.value == "today":
            return DeliveryChannel.VOICE_BRIEFING

        # Default to configured channel
        return self._config.default_channel

    def create_quick_action(
        self,
        label: str,
        action_type: str,
        payload: Dict[str, Any] = None
    ) -> QuickAction:
        """
        Create a quick action button.

        Args:
            label: Button label (e.g., "Send", "Schedule", "Dismiss")
            action_type: Type of action (e.g., "send", "schedule", "save")
            payload: Data needed to execute the action

        Returns:
            QuickAction object
        """
        return QuickAction(
            id=generate_id("action"),
            label=label,
            action_type=action_type,
            payload=payload or {},
        )

    # =========================================================================
    # STATUS
    # =========================================================================

    def get_status(self) -> Dict[str, Any]:
        """Get actor status."""
        return {
            "name": self.name,
            "description": self.description,
            "enabled": self._config.enabled,
            "handled_types": [t.value for t in self.handled_action_types],
            "prepared_count": self._prepared_count,
            "config": self._config.to_dict(),
        }

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}(name={self.name}, enabled={self._config.enabled})>"
